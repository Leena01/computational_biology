import numpy as np
from Bio.Phylo import BaseTree
from Bio.Phylo import draw
from Bio.Align import MultipleSeqAlignment
from collections import Counter
from tools.utils import remove_unprocessed

class Parsimony():
    """
    Class for methods using maximum parsimony.
    """

    def __init__(self, alignment: MultipleSeqAlignment, bnb: bool = True):
        """
        Constructor.

        alignment: MultipleSeqAlignment containing the alignment
        """
        self.tree = None # Best tree

        # Create the dictionary (and list) of taxa
        self.leaves = [] # Leaves as clades
        self.taxa = {} # Node-sequence pairs
        for sequence in alignment:
            leaf = BaseTree.Clade(None, sequence.id)
            self.leaves.append(leaf)

            # Create a list of sets containing bases
            base_sets = []
            for char in sequence.seq:
                base_sets.append({char})
            self.taxa[leaf] = base_sets

        self.size = len(self.leaves) # Number of taxa
        self.length = alignment.get_alignment_length() # Length of taxa
        self.bnb = bnb # Branch and bound. If false, use exhaustive search.

    def run(self):
        """
        Run the algorithm.
        """
        # Generate all the trees
        trees = self.generate_trees()

        # Maximum search
        for tree in trees:
            print(tree)
            print()

    def generate_trees(self):
        """
        Generate all possible trees.
        """
        first_leaf = self.leaves[0]
        first_leaf_sets = self.taxa[first_leaf]
        first_leaf_score = 0
        children_data = {}

        # The first tree, and the corresponding sets (that contain bases) along with the initial parsimony score
        # and the corresponding properties of the child nodes (which don't exist since the first node is a leaf).
        trees = [(first_leaf, first_leaf_sets, first_leaf_score, children_data)]

        # If there is only one species, return the current tree.
        if self.size == 1:
            return trees

        for i in range(1, 3):
            curr_leaf = self.leaves[i]
            new_trees = []
            for tree, sets, score, children_data in trees:
                new_trees.extend(self.add_leaf(tree, curr_leaf, sets, score, children_data))
            trees = new_trees

        # TODO optimize
        # Turn root nodes into trees.
        trees = [self._create_tree(tree) for tree, _, _, _ in trees]
        return trees

    def _calc_parsimony_score(
        self,
        left: BaseTree.Clade,
        right: BaseTree.Clade,
        left_sets: list,
        left_score: int,
        right_sets: list,
        right_score: int,
        threshold: int = np.inf):
        score = 0
        sets = []
        # TODO

        return True, sets, score

    def add_leaf(self,
        root: BaseTree.Clade,
        leaf: BaseTree.Clade,
        root_sets: list,
        root_score: int,
        children_data: dict,
        threshold: int = np.inf):
        """
        Add leaf to a tree.

        root: root defining the given tree
        leaf: leaf to be added
        root_sets: 
        root_score: 
        chidren_data: 
        threshold: the best result so far (the lower the better)

        returns: trees after the leaf has been added in every possible combination (represented by their roots)
        """
        # TODO: inner node names?
        new_trees = []

        # There are three different kinds of tree formation.

        # No. 1.: create a new root; let the old root be the left subtree and the leaf the right one.
        # If the calculated score is over the threshold, don't return this tree.
        # If it isn't, return both the new root and the corresponding score.
        under_threshold, sets_of_bases, score = \
            self._calc_parsimony_score(root, leaf, root_sets, root_score, self.taxa[leaf], 0, threshold)
        if under_threshold:
            inner_clade = self._create_inner_node(root, leaf)
            children_data = {
                'left_sets': root_sets,
                'left_score': root_score,
                'right_sets': self.taxa[leaf],
                'right_score': 0}
            new_trees.append((inner_clade, sets_of_bases, score, children_data))

        # If the root is a leaf, return current state.
        if not root.clades:
            return new_trees

        left = root.clades[0] # Left subtree
        right = root.clades[1] # right subtree

        # No. 2.: Append the leaf to the left subtree in every possible combination, recursively.
        # If the calculated score is over the threshold, don't return this tree.
        # If it isn't, return both the new root and the corresponding score.
        subtrees = self.add_leaf(left, leaf)
        for subtree, subtree_sets, subtree_score in subtrees:
            under_threshold, sets, score = \
                self._calc_parsimony_score(
                subtree,
                right,
                subtree_sets,
                subtree_score,
                children_data['right_sets'],
                children_data['right_score'],
                threshold)
            if under_threshold:
                inner_clade = self._create_inner_node(subtree, right)
                new_trees.append((inner_clade, sets, score, children_data))

        # No. 3.: Append the leaf to the right subtree in every possible combination, recursively.
        # If the calculated score is over the threshold, don't return this tree.
        # If it isn't, return both the new root and the corresponding score.
        subtrees = self.add_leaf(right, leaf)
        for subtree, subtree_sets, subtree_score in subtrees:
            under_threshold, sets, score = \
                self._calc_parsimony_score(
                left,
                subtree,
                children_data['left_sets'],
                children_data['left_score'],
                subtree_sets,
                subtree_score,
                threshold)
            if under_threshold:
                inner_clade = self._create_inner_node(left, subtree)
                new_trees.append((inner_clade, sets, score, children_data))

        return new_trees

    def _create_tree(self, root: BaseTree.Clade):
        """
        Create tree with given root.

        root: root

        returns: tree
        """
        return BaseTree.Tree(root, rooted=False)

    def _create_inner_node(self, left: BaseTree.Clade, right: BaseTree.Clade, name: str = None):
        """
        Create root with given left and right subtree.

        left: root of left subtree
        right: root of right subtree

        returns: root of new tree
        """
        root = BaseTree.Clade(None, name)
        root.clades.append(left)
        root.clades.append(right)
        return root

    def calc_parsimony(self, tree: BaseTree.Tree, parents: dict):
        """
        Fitch algorithm. Calculate score for every site (self.length).
        
        tree: tree
        parents: dictionary of parent nodes
        """

        sum = 0
        for u in range(self.length):
            sum += self.parsimony_for_site(tree, parents, u)

        return sum

    def parsimony_for_site(self, tree: BaseTree, parents: dict, u: int):
        """
        Calculate parsimony score for given site. From bottom to top.
        https://www.cs.helsinki.fi/bioinformatiikka/mbi/courses/07-08/itb/slides/itb0708_slides_158-191.pdf
        https://www.bio.fsu.edu/~stevet/BSC5936/Swofford.F2003.2.pdf
        https://tel.archives-ouvertes.fr/tel-01479049/document
        http://pages.stat.wisc.edu/~larget/Genetics629/Fall2009/outline2.pdf

        tree: tree
        parents: dictionary of parent nodes
        u: given site
        """
        score = 0 # Parsimony score.
        sets_of_bases = {} # Dictionary of sets. Format: {Leaf0: {'A'}, Leaf1: {'T'}, Leaf2: {'C'}, ..., InnerNode0: {'A', 'T', 'G'}}

        # Create the initial sets for leaves.
        nodes_to_be_processed = []
        for leaf in self.leaves:
            base = self.taxa[leaf][u]
            sets_of_bases[leaf] = {base}
            parent = parents[leaf]
            nodes_to_be_processed.append(parent)

        # Remove clades that do not occur as many times as how many children they have.
        nodes_to_be_processed = remove_unprocessed(nodes_to_be_processed)

        # Do this until we reach the root.
        while nodes_to_be_processed:
            next_nodes = []
            # Iterate over inner nodes.
            for node in nodes_to_be_processed:
                children = node.clades
                X = set() # Intersection
                Y = set() # Union

                # Find the intersection and the union of the children sets.
                for child in children:
                    set_of_base = sets_of_bases[child]
                    X = X.intersection(set_of_base)
                    Y = Y.union(set_of_base)
                # If not empty, X is the set belonging to the current node.
                if X:
                    sets_of_bases[node] = X
                # Otherwise, the set for the node is the union of the children sets and one is added to the score.
                else:
                    sets_of_bases[node] = Y
                    score += 1

                # Check if current node has a parent.
                if node in parents:
                    # Add the parent of the current node to the list of nodes to be processed.
                    next_nodes.append(parent)

            # Remove clades that do not occur as many times as how many children they have.
            nodes_to_be_processed = remove_unprocessed(next_nodes)

        return score
        
    def get_label(self, clade):
        """
        Prettify tree labels.

        clade: current clade
        returns: the label belonging to the current clade
        """
        if clade.name.startswith("Inner"):
            return ""
        return clade.name.replace("_", " ")

    def draw_tree(self, show_branch_labels=False):
        """
        Draws tree.

        show_branch_labels: show branch lengths; default is False
        """
        if self.tree is None:
            print("Please first build the tree.")
        else:
            if show_branch_labels:
                draw(self.tree, label_func=self.get_label, branch_labels=(lambda clade: clade.branch_length))
            else:
                draw(self.tree, label_func=self.get_label)